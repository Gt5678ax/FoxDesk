<?php
/**
 * FoxDesk - In-App Notification Functions
 *
 * Handles creation, retrieval, and management of persistent notifications.
 * Notifications are created directly at each event dispatch point
 * (not derived from activity_log).
 */

// ── Guard ────────────────────────────────────────────────────────────────────

/**
 * Check if notifications table exists (backward compat during rolling updates).
 */
function notifications_table_exists(): bool
{
    static $exists = null;
    if ($exists !== null) return $exists;
    try {
        $exists = (bool) db_fetch_one("SHOW TABLES LIKE 'notifications'");
    } catch (Throwable $e) {
        $exists = false;
    }
    return $exists;
}

// ── Create ───────────────────────────────────────────────────────────────────

/**
 * Create a single notification.
 *
 * @param int      $user_id   Recipient
 * @param string   $type      Event type (new_ticket, new_comment, status_changed, assigned_to_you, priority_changed, mentioned, due_date_reminder)
 * @param int|null $ticket_id Related ticket
 * @param int|null $actor_id  Who triggered the event
 * @param array    $data      Extra data (ticket_subject, actor_name, comment_preview, old_status, new_status, priority …)
 * @return int|false Inserted ID or false
 */
function create_notification(int $user_id, string $type, ?int $ticket_id, ?int $actor_id, array $data = [])
{
    if (!notifications_table_exists()) return false;

    return db_insert('notifications', [
        'user_id'    => $user_id,
        'ticket_id'  => $ticket_id,
        'type'       => $type,
        'actor_id'   => $actor_id,
        'data'       => json_encode($data, JSON_UNESCAPED_UNICODE),
        'is_read'    => 0,
        'created_at' => date('Y-m-d H:i:s'),
    ]);
}

/**
 * Create notifications for multiple users.
 * Skips the actor (you don't notify yourself) and respects user preference.
 *
 * @param int[]    $user_ids
 * @param string   $type
 * @param int|null $ticket_id
 * @param int|null $actor_id
 * @param array    $data
 */
function create_notifications_for_users(array $user_ids, string $type, ?int $ticket_id, ?int $actor_id, array $data = []): void
{
    if (!notifications_table_exists()) return;

    $user_ids = array_unique(array_map('intval', $user_ids));
    // Remove actor — you don't notify yourself
    $user_ids = array_filter($user_ids, fn($id) => $id > 0 && $id !== $actor_id);
    if (empty($user_ids)) return;

    // Check which users have in-app notifications enabled
    $placeholders = implode(',', array_fill(0, count($user_ids), '?'));
    $users = db_fetch_all(
        "SELECT id FROM users WHERE id IN ($placeholders) AND is_active = 1
         AND (in_app_notifications_enabled IS NULL OR in_app_notifications_enabled = 1)",
        array_values($user_ids)
    );

    $now = date('Y-m-d H:i:s');
    $json = json_encode($data, JSON_UNESCAPED_UNICODE);

    foreach ($users as $u) {
        try {
            db_insert('notifications', [
                'user_id'    => (int) $u['id'],
                'ticket_id'  => $ticket_id,
                'type'       => $type,
                'actor_id'   => $actor_id,
                'data'       => $json,
                'is_read'    => 0,
                'created_at' => $now,
            ]);
        } catch (Throwable $e) {
            // Silently skip — don't break the main flow
        }
    }
}

// ── Read ─────────────────────────────────────────────────────────────────────

/**
 * Get notifications for a user, newest first.
 *
 * @return array ['notifications' => [...], 'unread_count' => int]
 */
function get_user_notifications(int $user_id, int $limit = 50, int $offset = 0): array
{
    if (!notifications_table_exists()) {
        return ['notifications' => [], 'unread_count' => 0];
    }

    $rows = db_fetch_all(
        "SELECT n.*, u.first_name AS actor_first_name, u.last_name AS actor_last_name,
                u.avatar AS actor_avatar, u.email AS actor_email
         FROM notifications n
         LEFT JOIN users u ON u.id = n.actor_id
         WHERE n.user_id = ?
         ORDER BY n.created_at DESC
         LIMIT ? OFFSET ?",
        [$user_id, $limit, $offset]
    );

    // Decode JSON data
    foreach ($rows as &$row) {
        $row['data'] = json_decode($row['data'] ?? '{}', true) ?: [];
    }
    unset($row);

    $unread = get_unread_notification_count($user_id);

    return ['notifications' => $rows, 'unread_count' => $unread];
}

/**
 * Count notifications newer than last_notifications_seen_at (badge number).
 */
function get_unread_notification_count(int $user_id): int
{
    if (!notifications_table_exists()) return 0;

    $user = db_fetch_one("SELECT last_notifications_seen_at FROM users WHERE id = ?", [$user_id]);
    $seen_at = $user['last_notifications_seen_at'] ?? null;

    if ($seen_at) {
        $row = db_fetch_one(
            "SELECT COUNT(*) AS cnt FROM notifications WHERE user_id = ? AND created_at > ?",
            [$user_id, $seen_at]
        );
    } else {
        $row = db_fetch_one(
            "SELECT COUNT(*) AS cnt FROM notifications WHERE user_id = ? AND is_read = 0",
            [$user_id]
        );
    }

    return (int) ($row['cnt'] ?? 0);
}

/**
 * Get count of notifications that are not yet read (for polling badge).
 * Lightweight — returns just the number.
 */
function get_notification_badge_count(int $user_id): int
{
    return get_unread_notification_count($user_id);
}

// ── Mark Read ────────────────────────────────────────────────────────────────

/**
 * Mark a single notification as read.
 */
function mark_notification_read(int $notification_id, int $user_id): bool
{
    if (!notifications_table_exists()) return false;

    db_update('notifications', ['is_read' => 1], 'id = ? AND user_id = ?', [$notification_id, $user_id]);
    return true;
}

/**
 * Mark ALL notifications as read + update last_notifications_seen_at.
 */
function mark_all_notifications_read(int $user_id): bool
{
    if (!notifications_table_exists()) return false;

    $now = date('Y-m-d H:i:s');

    db_update('notifications', ['is_read' => 1], 'user_id = ? AND is_read = 0', [$user_id]);
    db_update('users', ['last_notifications_seen_at' => $now], 'id = ?', [$user_id]);
    return true;
}

/**
 * Update the "last seen" timestamp (called when bell panel is opened).
 */
function update_notifications_seen(int $user_id): void
{
    try {
        db_update('users', ['last_notifications_seen_at' => date('Y-m-d H:i:s')], 'id = ?', [$user_id]);
    } catch (Throwable $e) {
        // silent
    }
}

/**
 * Get snippet text for a notification, with fallbacks for all types.
 */
function get_notification_snippet(array $notif): string
{
    $data = $notif['data'] ?? [];

    // Stored comment/description preview (new_comment, new_ticket with preview)
    if (!empty($data['comment_preview'])) {
        return $data['comment_preview'];
    }

    switch ($notif['type']) {
        case 'new_ticket':
            // Fallback: fetch ticket description from DB
            if (!empty($notif['ticket_id'])) {
                $ticket = db_fetch_one("SELECT description FROM tickets WHERE id = ?", [(int) $notif['ticket_id']]);
                if ($ticket && !empty($ticket['description'])) {
                    $text = strip_tags($ticket['description']);
                    return mb_strlen($text) > 80 ? mb_substr($text, 0, 77) . '...' : $text;
                }
            }
            break;

        case 'assigned_to_you':
            return $data['ticket_subject'] ?? '';

        case 'status_changed':
            if (!empty($data['old_status']) && !empty($data['new_status'])) {
                return $data['old_status'] . ' → ' . $data['new_status'];
            }
            break;

        case 'priority_changed':
            if (!empty($data['old_priority']) && !empty($data['new_priority'])) {
                return $data['old_priority'] . ' → ' . $data['new_priority'];
            }
            break;

        case 'new_comment':
            // Fallback: fetch latest comment text from DB
            if (!empty($data['comment_id'])) {
                $comment = db_fetch_one("SELECT body FROM ticket_comments WHERE id = ?", [(int) $data['comment_id']]);
                if ($comment && !empty($comment['body'])) {
                    $text = strip_tags($comment['body']);
                    return mb_strlen($text) > 80 ? mb_substr($text, 0, 77) . '...' : $text;
                }
            }
            break;
    }

    return '';
}

// ── Recipients ───────────────────────────────────────────────────────────────

/**
 * Get all users who participated in a ticket (creator, assignee, commenters).
 *
 * @param int      $ticket_id
 * @param int|null $exclude_user_id  Usually the actor
 * @return int[] User IDs
 */
function get_ticket_participants(int $ticket_id, ?int $exclude_user_id = null): array
{
    $ids = [];

    // Ticket creator + assignee
    $ticket = db_fetch_one("SELECT user_id, assignee_id FROM tickets WHERE id = ?", [$ticket_id]);
    if ($ticket) {
        if (!empty($ticket['user_id']))     $ids[] = (int) $ticket['user_id'];
        if (!empty($ticket['assignee_id'])) $ids[] = (int) $ticket['assignee_id'];
    }

    // Commenters
    $commenters = db_fetch_all(
        "SELECT DISTINCT user_id FROM comments WHERE ticket_id = ?",
        [$ticket_id]
    );
    foreach ($commenters as $c) {
        $ids[] = (int) $c['user_id'];
    }

    $ids = array_unique($ids);
    if ($exclude_user_id) {
        $ids = array_filter($ids, fn($id) => $id !== $exclude_user_id);
    }

    return array_values($ids);
}

/**
 * Get all active agents and admins (optionally filtered by organization).
 *
 * @param int|null $org_id   If set, only staff in this org
 * @param int|null $exclude  User ID to exclude
 * @return int[]
 */
function get_staff_user_ids(?int $org_id = null, ?int $exclude = null): array
{
    $rows = db_fetch_all(
        "SELECT id FROM users WHERE role IN ('admin','agent') AND is_active = 1"
    );
    $ids = array_map(fn($r) => (int) $r['id'], $rows);

    if ($exclude) {
        $ids = array_filter($ids, fn($id) => $id !== $exclude);
    }

    return array_values($ids);
}

// ── Action Required ──────────────────────────────────────────────────────────

/**
 * Determine if a notification requires user action.
 */
function is_action_required_notification(string $type, array $data = []): bool
{
    switch ($type) {
        case 'assigned_to_you':
        case 'due_date_reminder':
            return true;
        case 'new_comment':
            return !empty($data['action_required']);
        default:
            return false;
    }
}

// ── Central Dispatcher ───────────────────────────────────────────────────────

/**
 * Dispatch in-app notifications for a ticket event.
 *
 * @param string   $event_type  new_ticket | new_comment | status_changed | assigned_to_you | priority_changed | due_date_reminder
 * @param int      $ticket_id
 * @param int      $actor_id    Who performed the action
 * @param array    $extra       Additional context data
 */
function dispatch_ticket_notifications(string $event_type, int $ticket_id, int $actor_id, array $extra = []): void
{
    if (!notifications_table_exists()) return;

    // Fetch ticket for context
    $ticket = db_fetch_one("SELECT id, title, description, user_id, assignee_id, status_id, priority_id FROM tickets WHERE id = ?", [$ticket_id]);
    if (!$ticket) return;

    // Fetch actor name
    $actor = db_fetch_one("SELECT first_name, last_name FROM users WHERE id = ?", [$actor_id]);
    $actor_name = $actor ? trim($actor['first_name'] . ' ' . ($actor['last_name'] ?? '')) : 'System';

    // Build base data payload
    $data = array_merge([
        'ticket_subject' => $ticket['title'] ?? '',
        'ticket_id'      => (int) $ticket['id'],
        'actor_name'     => $actor_name,
    ], $extra);

    // Set action_required flag based on event type
    $data['action_required'] = in_array($event_type, ['assigned_to_you', 'due_date_reminder'], true);

    // Auto-add description preview for new_ticket if not provided
    if ($event_type === 'new_ticket' && empty($data['comment_preview']) && !empty($ticket['description'])) {
        $desc_text = strip_tags($ticket['description']);
        $data['comment_preview'] = mb_strlen($desc_text) > 80 ? mb_substr($desc_text, 0, 77) . '...' : $desc_text;
    }

    // Determine recipients based on event type
    $recipients = [];

    switch ($event_type) {
        case 'new_ticket':
            // Notify all staff (agents + admins)
            $recipients = get_staff_user_ids(null, $actor_id);
            break;

        case 'new_comment':
            // Notify ticket participants (creator, assignee, previous commenters)
            $recipients = get_ticket_participants($ticket_id, $actor_id);
            $assignee_id = !empty($ticket['assignee_id']) ? (int) $ticket['assignee_id'] : 0;

            // Assignee gets action_required=true (they need to respond)
            if ($assignee_id > 0 && $assignee_id !== $actor_id && in_array($assignee_id, $recipients)) {
                $assignee_data = array_merge($data, ['action_required' => true, 'recipient_is_assignee' => true]);
                create_notifications_for_users([$assignee_id], $event_type, $ticket_id, $actor_id, $assignee_data);
                // Remove assignee from remaining recipients
                $recipients = array_filter($recipients, fn($id) => $id !== $assignee_id);
            }
            break;

        case 'status_changed':
            // Notify ticket creator + assignee
            $ids = [];
            if (!empty($ticket['user_id']))     $ids[] = (int) $ticket['user_id'];
            if (!empty($ticket['assignee_id'])) $ids[] = (int) $ticket['assignee_id'];
            $recipients = array_unique($ids);
            break;

        case 'assigned_to_you':
            // Notify the newly assigned agent
            $assignee_id = (int) ($extra['assignee_id'] ?? 0);
            if ($assignee_id > 0 && $assignee_id !== $actor_id) {
                $recipients = [$assignee_id];
            }
            break;

        case 'priority_changed':
            // Notify ticket participants
            $recipients = get_ticket_participants($ticket_id, $actor_id);
            break;

        case 'due_date_reminder':
            // Notify assignee, or all staff if unassigned
            if (!empty($ticket['assignee_id'])) {
                $recipients = [(int) $ticket['assignee_id']];
            } else {
                $recipients = get_staff_user_ids();
            }
            break;
    }

    if (!empty($recipients)) {
        create_notifications_for_users($recipients, $event_type, $ticket_id, $actor_id, $data);
    }
}

// ── Formatting ───────────────────────────────────────────────────────────────

/**
 * Format notification text for display.
 *
 * @param array $notification Full notification row with decoded data
 * @return string Translated text
 */
function format_notification_text(array $notification): string
{
    $data = $notification['data'] ?? [];
    $actor = $data['actor_name'] ?? t('Someone');
    $subject = $data['ticket_subject'] ?? '';

    // Truncate subject to 50 chars
    if (mb_strlen($subject) > 50) {
        $subject = mb_substr($subject, 0, 47) . '...';
    }

    switch ($notification['type'] ?? '') {
        case 'new_ticket':
            return t('{actor} created a new ticket: {subject}', ['actor' => $actor, 'subject' => $subject]);

        case 'new_comment':
            $preview = $data['comment_preview'] ?? '';
            if ($preview) {
                return t('{actor} commented on {subject}', ['actor' => $actor, 'subject' => $subject]);
            }
            return t('{actor} commented on {subject}', ['actor' => $actor, 'subject' => $subject]);

        case 'status_changed':
            $new_status = $data['new_status'] ?? '';
            return t('{actor} changed status to {status} on {subject}', [
                'actor' => $actor, 'status' => $new_status, 'subject' => $subject
            ]);

        case 'assigned_to_you':
            return t('{actor} assigned you to {subject}', ['actor' => $actor, 'subject' => $subject]);

        case 'priority_changed':
            $new_priority = $data['new_priority'] ?? '';
            return t('{actor} changed priority to {priority} on {subject}', [
                'actor' => $actor, 'priority' => $new_priority, 'subject' => $subject
            ]);

        case 'due_date_reminder':
            $due = $data['due_date'] ?? '';
            return t('Ticket {subject} is due {date}', ['subject' => $subject, 'date' => $due]);

        default:
            return t('New notification');
    }
}

/**
 * Relative time string ("2 min ago", "3 hours ago", "Yesterday", …).
 */
function notification_time_ago(string $datetime): string
{
    $now = time();
    $ts = strtotime($datetime);
    $diff = $now - $ts;

    if ($diff < 60)        return t('just now');
    if ($diff < 3600)      return t('{n} min ago', ['n' => (int) floor($diff / 60)]);
    if ($diff < 86400)     return t('{n}h ago', ['n' => (int) floor($diff / 3600)]);
    if ($diff < 172800)    return t('yesterday');
    if ($diff < 604800)    return t('{n} days ago', ['n' => (int) floor($diff / 86400)]);

    return date('j M', $ts);
}

/**
 * Group notifications into "today", "yesterday", "earlier".
 *
 * @param array $notifications
 * @return array ['today' => [...], 'yesterday' => [...], 'earlier' => [...]]
 */
function group_notifications(array $notifications): array
{
    $today_start = strtotime('today 00:00:00');
    $yesterday_start = strtotime('yesterday 00:00:00');

    $grouped = ['today' => [], 'yesterday' => [], 'earlier' => []];

    foreach ($notifications as $n) {
        $ts = strtotime($n['created_at']);
        if ($ts >= $today_start) {
            $grouped['today'][] = $n;
        } elseif ($ts >= $yesterday_start) {
            $grouped['yesterday'][] = $n;
        } else {
            $grouped['earlier'][] = $n;
        }
    }

    return $grouped;
}

// ── Cleanup ──────────────────────────────────────────────────────────────────

/**
 * Delete old read notifications. Call from maintenance cron.
 *
 * @param int $days Keep notifications for this many days
 * @return int Number of deleted rows
 */
function cleanup_old_notifications(int $days = 90): int
{
    if (!notifications_table_exists()) return 0;

    $cutoff = date('Y-m-d H:i:s', strtotime("-{$days} days"));

    try {
        db_query("DELETE FROM notifications WHERE is_read = 1 AND created_at < ?", [$cutoff]);
        $deleted = db_fetch_one("SELECT ROW_COUNT() AS cnt");
        return (int) ($deleted['cnt'] ?? 0);
    } catch (Throwable $e) {
        return 0;
    }
}
